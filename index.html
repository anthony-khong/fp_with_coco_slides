<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/simple.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/solarized.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
<div class="reveal"> <div class="slides">
    <section id="title_page">
        <h2><span style="color:slateblue">Pythonic FP with Coconut</span></h2>
        <h4>Anthony Khong</h4>
        <h4>16 June 2018</h4>
    </section>

    <section id="contents">
        <ol>
            <li>Functional Programming</li>
            <li>Declarative Programming by Example</li>
            <li>Coconut for Machine Learning Pipeline</li>
        </ol>
    </section>

    <section id="fp">
        <section id="fp_title_page">
            <h2> <span style="color:slateblue">Functional Programming</span></h2>
        </section>
        <section id="immutability">
            <h2> <span style="color:slateblue">Immutability</span></h2>
            <p>Once assigned, a variable <span style="color:red">cannot</span> change its value.</p>
            <aside class="notes">
                - The main idea here is that you work with pure functions.
                - Purity in the mathematical sense: the same inputs give you the same outputs.
                - In OO, you often work with stateful objects. A method is most definitely not a pure function.
            </aside>
        </section>
        <section data-markdown id="python_immutability1"><textarea data-template>
            ```python
            >>> def g(xs):
            ...     ???
            ...
            >>> def f(xs):
            ...     return xs + [999]
            ...
            >>> xs = [1, 2, 3]
            >>> ys = g(xs)
            >>> f(xs)
            ???
            ```
        </textarea></section>
        <section data-markdown id="python_immutability2"><textarea data-template>
            ```python
            >>> def g(xs):
            ...     xs.reverse()
            ...     return xs
            ...
            >>> def f(xs):
            ...     return xs + [999]
            ...
            >>> xs = [1, 2, 3]
            >>> ys = g(xs)
            >>> f(xs)
            [3, 2, 1, 999]
            ```
            <aside class="notes">
                - We say that Python lists are mutable. It carries with it state.
                - From the point where you define xs, you cannot guarantee that it's the same object.
                - It is not enough to have xs and the definition of f to find out what f(xs) is.
                - Here, g is not a pure function, because it modifies a global state. In some sense it is lying to you.
            </aside>
        </textarea></section>
        <section data-markdown id="python_immutability3"><textarea data-template>
            ```python
            >>> def g(xs):
            ...     return xs[::-1]
            ...
            >>> def f(xs):
            ...     return xs + [999]
            ...
            >>> xs = [1, 2, 3]
            >>> ys = g(xs)
            >>> f(xs)
            [1, 2, 3, 999]
            ```
            <aside class="notes">
                - Superficially, both g and f are doing the same thing as before.
                - **Compare the two slides.**
                - But we changed the implementation of g to make it a pure function.
                - The diff between reverse and negative step is that the latter makes a new list.
            </aside>
        </textarea></section>
        <section data-markdown id="haskell_immutability1"><textarea data-template>
            ```haskell
            λ> g x = ???
            λ> f x = x ++ [999]
            λ> xs = [1, 2, 3]
            λ> ys = g xs
            λ> f xs
            ???
            ```
            <aside class="notes">
                - **Explain Haskell syntax carefully.**
                - In Haskell you can always guarantee the value of `f xs`.
                - Anything else, it won't type check. Haskell won't let you do side effects.
            </aside>
        </textarea></section>
        <section data-markdown id="haskell_immutability2"><textarea data-template>
            ```haskell
            λ> g x = undefined
            λ> f x = x ++ [999]
            λ> xs = [1, 2, 3]
            λ> ys = g xs
            λ> f xs
            [1, 2, 3, 999]
            ```
            <aside class="notes">
                - There something called the **bottom**, which represents never-ending computation.
            </aside>
        </textarea></section>
        <section data-markdown id="haskell_immutability3"><textarea data-template>
            ```haskell

            λ> f x = x ++ [999]
            λ> xs = [1, 2, 3]

            λ> f xs
            [1, 2, 3, 999]
            ```
            <aside class="notes">
                - In a real sense, you don't need to know what g is in order to know what `f xs` is. They are irrelevant.
                - In terms of decoupling. This is a small example that works.
                - In reality, the side effect could happen somewhere deep in the codebase, where it'd be hard to debug.
                - Decoupling is good, because you can work with smaller chunks.
            </aside>
        </textarea></section>
        <section id="immutability_gives_predictability">
            <h3><span style="color:slateblue">Immutability = Predictability</span></h3>
            <aside class="notes">
                - You'll hear this term a lot from functional programmers. "Your code is easier to reason about."
                - This is what it boils down to. Without state, your code is predictable.
            </aside>
        </section>
    </section>

    <section id="declarative_programming">
        <section id="declarative_programming_title_page">
            <h2><span style="color:slateblue">Declarative Programming</span></h2>
            <aside class="notes">
                - As a by-product of functional programming, you often write declarative code instead of imperative code.
            </aside>
        </section>

        <section id="declarative_vs_imperative">
            <h2><span style="color:slateblue">Declarative vs. Imperative</span></h2>

            Say <span style="color:blue">what things are</span> rather than <span style="color:red">how things are done</span>.

            <aside class="notes">
                - Take loops as example, how can you implement a loop without changing things? Many times your index always changes!
                - There are two alternatives for loops: list comprehensions and maps.
                - If you think about them, they're definitions instead of an instruction to change things.
                - Let's look at a bigger example.
            </aside>
        </section>
        <section id="sieve_subtitle_page">
            <h2><span style="color:slateblue">Sieve of Eratosthenes</span></h2>
            <aside class="notes">
                - The idea here is that we'd like to find all prime numbers.
                - So the objective here is to make an infinite stream of prime numbers.
                - Here is how we do it...
            </aside>
        </section>
        <section id="sieve_init">
            <img data-src="figures/sieve.png" width="66%">
            <aside class="notes">
                - Start with a stream of numbers starting from two to infinity.
                - Take the head of the stream, and filter out all factors of the head.
                - Repeat this step ad infinitum.
                - Here is an illustration of the algorithm.
            </aside>
        </section>
        <section id="sieve_animation">
            <img data-src="figures/sieve.gif" width="66%">
        </section>
        <section data-markdown id="sieve_haskell"><textarea data-template>
            <h4><span style="color:slateblue">Haskell</span></h4>
            ```haskell
            primes :: [Int]
            primes = sieve [2..]
            where
                sieve (x:xs) = x : sieve (filter (\n -> n `mod` x /= 0) xs)
                sieve []     = []

            λ> takeWhile (<60) primes
            [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59]
            ```
            <aside class="notes">
                - Carefully go through the Haskell syntax.
            </aside>
        </textarea></section>
        <section data-markdown id="sieve_python"><textarea data-template>
            <h4><span style="color:darkgreen">Python</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> list(takewhile(lambda x: x < 60, primes()))
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
            <aside class="notes">
                - Note the difference between declarative and imperative programming.
                - Now I'd like to introduce Coconut...
            </aside>
        </textarea></section>
        <section data-markdown id="sieve_coconut"><textarea data-template>
            <h4><span style="color:mediumseagreen">Coconut</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> list(takewhile(lambda x: x < 60, primes()))
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
            <aside class="notes">
                - The first thing to note here is that Coconut is a superset of Python.
                - All valid Python is valid Coconut. So you can just write Python if you'd like.
                - Massage this imperative code to make it 1) more idiomatic and 2) more declarative.
                - First up is this clunky lambda syntax...
            </aside>
        </textarea></section>
        <section data-markdown id="concise_lambdas"><textarea data-template>
            <h4><span style="color:mediumseagreen">Concise Lambdas</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> list(takewhile(x -> x < 60, primes()))
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
            <aside class="notes">
                - In Coconut, we can simply write an arrow for a lambda.
                - It may seem minor, but if you're writing functional code, you often pass functions as arguments.
                - In fact, this is how you should pass behaviours around instead of objects with methods.
                - In that case, you'd like your building blocks to be as concise as possible.
                - It may seem small, but this is very very nice to write functional codes with.
                - Next up is functional composition...
            </aside>
        </textarea></section>
        <section data-markdown id="forward_piping"><textarea data-template>
            <h4><span style="color:mediumseagreen">Forward Piping</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> primes() |> ns -> takewhile(x -> x < 60, ns) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
            <aside class="notes">
                - Instead of clumsy brackets, Coconut gives us a forward pipe operator that allows to do F# style code.
                - There is another type of composition: the dot composition.
                - It's right to left instead of left to right, which is similar to Haskell.
                - Whatever you choose Haskell-style or F#-style it's more readable than the original.
                - I've softened up on this after doing some Clojure, but I'd still prefer the F#-style code.
                - Next up is currying...
            </aside>
        </textarea></section>
        <section data-markdown id="currying"><textarea data-template>
            <h4><span style="color:mediumseagreen">Currying</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
        </textarea></section>
        <section data-markdown id="iterator_chaining"><textarea data-template>
            <h4><span style="color:mediumseagreen">Iterator Chaining</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    return [head] :: sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
        </textarea></section>
        <section data-markdown id="pattern_matching"><textarea data-template>
            <h4><span style="color:mediumseagreen">Pattern Matching</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve([head] :: tail):
                    return [head] :: sieve(n for n in tail if n % head)
                return sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
        </textarea></section>
        <section data-markdown id="function_assignments"><textarea data-template>
            <h4><span style="color:mediumseagreen">Function Assignments</span></h4>
            ```python
            from itertools import count, takewhile

            def primes() =
                def sieve([x] :: xs) = [x] :: sieve(n for n in xs if n % x)
                sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
        </textarea></section>
        <section data-markdown id="builtin_hofs"><textarea data-template>
            <h4><span style="color:mediumseagreen">Builtin Higher-Order Functions</span></h4>
            ```python
            def primes() =
                def sieve([x] :: xs) = [x] :: sieve(n for n in xs if n % x)
                sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]
            ```
        </textarea></section>

        <section data-markdown id="coconut_vs_python"><textarea data-template>
            <h4><span style="color:mediumseagreen">Coconut</span></h4>
            ```python
            def primes() =
                def sieve([x] :: xs) = [x] :: sieve(n for n in xs if n % x)
                sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            ```

            <h4><span style="color:darkgreen">Python</span></h4>
            ```python
            from itertools import count, takewhile

            def primes():
                def sieve(numbers):
                    head = next(numbers)
                    yield head
                    yield from sieve(n for n in numbers if n % head)
                return sieve(count(2))

            >>> list(takewhile(x -> x < 60, primes()))
            ```
        </textarea></section>
        <section data-markdown id="coconut_and_haskell"><textarea data-template>
            <h4><span style="color:mediumseagreen">Coconut</span></h4>
            ```python
            def primes() =
                def sieve([x] :: xs) = [x] :: sieve(n for n in xs if n % x)
                sieve(count(2))

            >>> primes() |> takewhile$(x -> x < 60) |> list
            ```

            <h4><span style="color:slateblue">Haskell</span></h4>
            ```haskell
            primes :: [Int]
            primes = sieve [2..]
            where
                sieve (x:xs) = x : sieve (filter (\n -> n `rem` x /= 0) xs)
                sieve []     = []

            λ> takeWhile (<60) primes
            ```
        </textarea></section>
        <section id="vince_macmahon">
            <img data-src="figures/vince_macmahon.gif" width="85%">
        </section>
    </section>

    <section id="pipeline">
        <section id="pipeline_title_page">
            <h2><span style="color:slateblue">Machine Learning Pipeline</span></h2>
        </section>
        <section id="estimator_transformer_flowchart">
            <img data-src="figures/estimator_transformer_flowchart.png" width="150%">
        </section>
        <section id="pipeline_flowchart">
            <img data-src="figures/pipeline_flowchart.png" width="100%">
        </section>
        <section id="type_tetris_chart">
            <img data-src="figures/pipeline_scheme.png" width="60%">
        </section>
        <section data-markdown><textarea data-template>
            <h3><span style="color:slateblue">Haskell-Style Type Tetris</span></h3>

            ```haskell
            Estimator     = Estimator (DataFrame -> Transformer)
            Transformer   = Transformer (DataFrame -> DataFrame)
            PipelineStage = Estimator | Transformer

            fit           :: PipelineStage   -> DataFrame -> Transformer
            transform     :: Transformer     -> DataFrame -> DataFrame
            pipeline      :: [PipelineStage] -> PipelineStage
            ```
        </textarea></section>
        <section data-markdown><textarea data-template>
            ```python
            data Estimator(fit_fn)
            data Transformer(xform_fn)
            ```
            <p></p>
            <img data-src="figures/data_scheme.png" width="80%">
        </textarea></section>
        <section data-markdown><textarea data-template>
            ```python
            def transform(Transformer(xform_fn), df) = xform_fn(df)
            ```
            <p></p>
            <img data-src="figures/transform_scheme.png" width="80%">
        </textarea></section>
        <section data-markdown><textarea data-template>
            ```python
            def fit(Estimator(fit_fn), df) = fit_fn(df)

            @addpattern(fit)
            def fit(Transformer(xform_fn), _) = Transformer(xform_fn)
            ```
            <p></p>
            <img data-src="figures/fit_scheme.png" width="70%">
        </textarea></section>
        <section>
            <h3><span style="color:slateblue">What about Pipeline?</span></h3>
            <p></p>
            <img data-src="figures/pipeline_only_scheme.png" width="80%">
            <p></p>

            <section data-markdown class="fragment fade-up"><textarea data-template>
```python
def pipeline(stages):
    def fit_fn(train_df):
        fitted_stages = [fit(s, train_df) for s in stages]
        def xform_fn(test_df):
            for fs in fited_stages:
                test_df = transform(fs, test_df)
            return test_df
        return Transformer(xform_fn)
    return Estimator(fit_fn)
```
            </textarea></section>
        </section>
        <section>
            <img data-src="figures/red_card.gif" width="80%">
        </section>
        <section data-markdown><textarea data-template>
            <h3><span style="color:slateblue">Pipeline Forms a Monoid</span></h3>

            ```haskell
            pipeline      :: [PipelineStage] -> PipelineStage
            ```

            <img data-src="figures/monoid.png" width="30%">
        </textarea></section>
        <section data-markdown><textarea data-template>
            <h3><span style="color:slateblue">What is a Monoid?</span></h3>

            ```haskell
            class Monoid m where
                mempty :: m
                mappend :: m -> m -> m

                mconcat :: [m] -> m
                mconcat = foldr mappend mempty
            ```

            <img data-src="figures/mconcat.png" width="30%">
        </textarea></section>
        <section data-markdown><textarea data-template>
            ```python
            def mempty() = Transformer(df -> df)

            def mappend(Transformer(fn0), Transformer(fn1)) =
                Transformer(fn1..fn0)

            @addpattern(mappend)
            def mappend(stage0, stage1) =
                Estimator(df -> mappend(fit(stage0, df), fit(stage1, df)))

            def mconcat(stages) = reduce(mappend, stages)
            pipeline = mconcat
            ```
            <p></p>
            <img data-src="figures/pipeline_stage_scheme.png" width="80%">
        </textarea></section>
        <section data-markdown><textarea data-template>
            <h3><span style="color:slateblue">ML Pipeline in Coconut</span></h3>

            ```python
            data Estimator(fit_fn)
            data Transformer(xform_fn)

            def transform(Transformer(xform_fn), df) = xform_fn(df)

            def fit(Estimator(fit_fn), df) = fit_fn(df)

            @addpattern(fit)
            def fit(Transformer(xform_fn), _) = Transformer(xform_fn)
            ```

            ```python
            def mempty() = Transformer(df -> df)

            def mappend(Transformer(fn0), Transformer(fn1)) =
                Transformer(fn1..fn0)

            @addpattern(mappend)
            def mappend(stage0, stage1) =
                Estimator(df -> mappend(fit(stage0, df), fit(stage1, df)))

            def mconcat(stages) = reduce(mappend, stages)
            pipeline = mconcat
            ```
        </textarea></section>
        <section>
            <h3><span style="color:slateblue">One Hot Encoder</span></h3>
        </section>
        <section>
            <h3><span style="color:slateblue">Feedforward Neural Network</span></h3>
        </section>
        <section>
            <h3><span style="color:slateblue">Coconut Pipeline in Action</span></h3>
        </section>
    </section>


</div> </div>
        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                transition: "none",
                history: true,
                math: {
                    mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
                    config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
                },
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/math/math.js', async: true }
                ]
            });
        </script>
    </body>
</html>
